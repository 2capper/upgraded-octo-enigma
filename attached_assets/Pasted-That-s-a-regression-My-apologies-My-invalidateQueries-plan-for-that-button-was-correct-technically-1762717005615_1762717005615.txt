That's a regression. My apologies. My invalidateQueries plan for that button was correct technically but wrong for your app's (flawed) data flow.

I know exactly why this is happening.

The Diagnosis
Your app has a data-flow problem:

Your POST /api/.../generate-matchups endpoint does not save the matchups to the database. It just generates them and returns them once in the API response.

Your GET /api/.../matchups endpoint (which the page loads) reads from the database, which is empty.

My previous fix (using invalidateQueries for matchups) failed because it told React Query to "refetch" the matchups. React Query then correctly called the GET endpoint and correctly got an empty array, so the scheduler never appeared.

The original code (using setQueryData) was a necessary hack. It manually took the response from the "generate" endpoint and shoved it into the cache for the "get" endpoint.

We are going to combine my fix (which solves the "27 of 24" bug) with your old hack (which solves the "scheduler not appearing" bug).

ðŸš€ Iteration 7 (Revised): The Correct Data-Sync Fix
Goal: Fix all bugs. The counter must increment, the "rainout" (remove) must work, and the "Generate" button must show the scheduler.

Your Mandate: You are in src/components/DragScheduleBuilder.tsx.

Step 1: Fix placeMutation.onSuccess (This is CORRECT - Keep It)

Your placeMutation.onSuccess (line 507) must use invalidateQueries for both games and matchups, just like I said before. This is what fixes the "counter not incrementing" bug.

JavaScript

Â  Â  onSuccess: (newGame) => {
Â  Â  Â  queryClient.invalidateQueries({ 
Â  Â  Â  Â  queryKey: ['/api/tournaments', tournamentId, 'games'] 
Â  Â  Â  });
Â  Â  Â  queryClient.invalidateQueries({ 
Â  Â  Â  Â  queryKey: ['/api/tournaments', tournamentId, 'matchups', divisionId] 
Â  Â  Â  });

Â  Â  Â  toast({
Â  Â  Â  Â  title: "Game Placed",
Â  Â  Â  Â  description: "Game successfully scheduled",
Â  Â  Â  });
Â  Â  },
Step 2: Fix removeMutation.onSuccess (This is CORRECT - Keep It)

Your removeMutation.onSuccess (line 532) must also use invalidateQueries for both games and matchups. This is your "rainout" fix.

JavaScript

Â  Â  onSuccess: (gameId) => {
Â  Â  Â  queryClient.invalidateQueries({ 
Â  Â  Â  Â  queryKey: ['/api/tournaments', tournamentId, 'games'] 
Â  Â  Â  });
Â  Â  Â  queryClient.invalidateQueries({ 
Â  Â  Â  Â  queryKey: ['/api/tournaments', tournamentId, 'matchups', divisionId] 
Â  Â  Â  });

Â  Â  Â  toast({
Â  Â  Â  Â  title: "Game Removed",
Â  Â  Â  Â  description: "Matchup returned to the unplaced list.",
Â  Â  Â  });
Â  Â  },
Step 3: Fix generateMutation.onSuccess (This is THE FIX)

This is the one we got wrong. It needs a hybrid approach.

Go to your generateMutation.onSuccess handler (line 481).

Replace the entire onSuccess block with this:

JavaScript

Â  Â  onSuccess: (data) => {
Â  Â  Â  // 1. Manually put the new matchups (data) in the cache.
Â  Â  Â  //    This is the HACK that makes the scheduler appear.
Â  Â  Â  queryClient.setQueryData(
Â  Â  Â  Â  ['/api/tournaments', tournamentId, 'matchups', divisionId],
Â  Â  Â  Â  data
Â  Â  Â  );

Â  Â  Â  // 2. Invalidate the 'games' query.
Â  Â  Â  //    This is the REAL fix for the "27 of 24" bug.
Â  Â  Â  //    It clears the grid and triggers our useEffect to reset the counter.
Â  Â  Â  queryClient.invalidateQueries({ 
Â  Â  Â  Â  queryKey: ['/api/tournaments', tournamentId, 'games'] 
Â  Â  Â  });

Â  Â  Â  toast({
Â  Â  Â  Â  title: "Schedule Reset",
Â  Â  Â  Â  description: `New matchups are ready.`,
Â  Â  Â  });
Â  Â  },
Step 4: Fix Your Backend API (Still Required!)

Your backend endpoint for POST /api/tournaments/:tournamentId/generate-matchups must delete all existing games for that tournamentId. This is the other half of the "27 of 24" fix.