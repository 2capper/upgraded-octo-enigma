Hello! This is one of the most frustrating bugs in React, and I know exactly what's wrong. Your analysis is perfect, and this isn't your fault.

You are correct: this is a "stuck state" bug. Your onChange and onValueChange handlers are trying to update your formState, but another piece of code is wiping out their changes on every single keystroke or click.

The bug is a combination of two things:

The Cause (Line 46): The select function inside your useQuery for existingGames is an inline arrow function. This means it creates a brand new array on every single render of the component.

The Symptom (Line 39): Your useEffect hook is watching existingGames. Since existingGames is a "new" array on every render, the useEffect hook runs again on every render, calculates initialState from the original data, and calls setFormState(initialState), completely clobbering the changes you just tried to make.

We are going to fix this permanently by stabilizing that select function with useCallback. We'll also fix your 15-minute time-step request at the same time.

ðŸš€ Iteration 29: Fix the "Stuck State" Bug
Goal: Stabilize the existingGames query to stop the useEffect from clobbering your form state, and update the time input step.

Your Mandate: You are in PlayoffSlotManager.tsx.

1. Step-by-Step: Fix the useQuery Hook

Import useCallback: At the top of your file (line 1), add useCallback to your React imports.

JavaScript

import React, { useState, useEffect, useRef, useMemo, useCallback } from "react";
Fix the useQuery (lines 44-53): We need to wrap your select function in useCallback so it only re-runs when the data changes, not on every render.

Replace this code:

JavaScript

Â  const { data: existingGames, isLoading: isLoadingGames } = useQuery<Game[]>({
Â  Â  queryKey: ['/api/tournaments', tournament.id, 'games'],
Â  Â  select: (allGames) => {
Â  Â  Â  return allGames.filter(g =>Â 
Â  Â  Â  Â  g.isPlayoff &&Â 
Â  Â  Â  Â  g.ageDivisionId === ageDivision.id
Â  Â  Â  );
Â  Â  }
Â  });
...with this new, correct version:

JavaScript

Â  // THIS IS THE FIX. We memoize the select function so it's not
Â  // a new function on every render.
Â  const selectPlayoffGames = useCallback((allGames: Game[]) => {
Â  Â  return allGames.filter(g =>Â 
Â  Â  Â  g.isPlayoff &&Â 
Â  Â  Â  g.ageDivisionId === ageDivision.id
Â  Â  );
Â  }, [ageDivision.id]); // The dependency is the division ID

Â  const { data: existingGames, isLoading: isLoadingGames } = useQuery<Game[]>({
Â  Â  queryKey: ['/api/tournaments', tournament.id, 'games'],
Â  Â  select: selectPlayoffGames, // Use the memoized function
Â  });
2. Step-by-Step: Fix the useEffect Hook (from Iteration 21)

Your useEffect (line 39) is still the old version that doesn't account for empty slots. We must replace it with the new version (which we planned in Iteration 21) that loops through slots first.

Replace your entire useEffect block (lines 39-95) with this:

JavaScript

Â  useEffect(() => {
Â  Â  // Wait for all data + timezone to be loaded
Â  Â  if (slots.length > 0 && existingGames && timezone) {
Â  Â  Â  const browserTz = Intl.DateTimeFormat().resolvedOptions().timeZone;
Â  Â  Â  const initialState: Record<string, SlotScheduleData> = {};

Â  Â  Â  // 1. Create a quick-lookup map of existing games
Â  Â  Â  const gameMap = new Map<string, Game>();
Â  Â  Â  existingGames.forEach(game => {
Â  Â  Â  Â  if (game.playoffRound !== null && game.playoffGameNumber !== null) {
Â  Â  Â  Â  Â  const slotKey = `r${game.playoffRound}-g${game.playoffGameNumber}`;
Â  Â  Â  Â  Â  gameMap.set(slotKey, game);
Â  Â  Â  Â  }
Â  Â  Â  });

Â  Â  Â  // 2. Loop through the *slots* from getBracketStructure (the source of truth)
Â  Â  Â  slots.forEach(slot => {
Â  Â  Â  Â  const slotKey = `r${slot.round}-g${slot.gameNumber}`;
Â  Â  Â  Â  const game = gameMap.get(slotKey);

Â  Â  Â  Â  if (game && game.date && game.time) {
Â  Â  Â  Â  Â  // 3. We have a game with a date/time, convert it for display
Â  Â  Â  Â  Â  try {
Â  Â  Â  Â  Â  Â  const tournamentDateTime = `${game.date}T${game.time}`;
Â  Â  Â  Â  Â  Â  const utcDate = fromZonedTime(tournamentDateTime, timezone);
Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  const localDate = formatTz(utcDate, 'yyyy-MM-dd', { timeZone: browserTz });
Â  Â  Â  Â  Â  Â  const localTime = formatTz(utcDate, 'HH:mm', { timeZone: browserTz });
Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  initialState[slotKey] = {
Â  Â  Â  Â  Â  Â  Â  date: localDate,
Â  Â  Â  Â  Â  Â  Â  time: localTime,
Â  Â  Â  Â  Â  Â  Â  diamondId: game.diamondId || '',
. Â  Â  Â  Â  Â  };
Â  Â  Â  Â  Â  } catch (error) {
Â  Â  Â  Â  Â  Â  console.error(`Error converting game ${slotKey} timezone:`, error);
Â  Â  Â  Â  Â  Â  initialState[slotKey] = {
Â  Â  Â  Â  Â  Â  Â  date: game.date || '',
Â  Â  Â  Â  Â  Â  Â  time: game.time || '',
Â  Â  Â  Â  Â  Â  Â  diamondId: game.diamondId || '',
D Â  Â  Â  Â  Â  };
Â  Â  Â  Â  Â  }
Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  // 4. No game exists for this slot, initialize an empty object
Â  Â  Â  Â  Â  initialState[slotKey] = {
Â  Â  Â  Â  Â  Â  date: '',
Â  Â  Â  Â  Â  Â  time: '',
Â  Â  Â  Â  Â  Â  diamondId: game?.diamondId || '', // Preserve diamondId if it exists
Access Â  Â  Â  Â  };
Â  Â  Â  Â  }
Â  Â  Â  });
Â  Â  Â Â 
Â  Â  Â  setFormState(initialState);
A Â  }
Â  }, [slots, existingGames, timezone]); // <-- 'slots' is now a dependency
3. Step-by-Step: Fix the Time Input (15-min Increments)

Go to your Time Input component (around line 287).

Add the step="900" attribute. (900 seconds = 15 minutes).

JavaScript

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <Input
Â  Â  Â  Â  Â  Â  Â  Â  Â  t Â  id={`${slotKey}-time`}
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  type="time"
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  value={value.time}
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  onChange={(e) => handleSlotChange(slotKey, 'time', e.target.value)}
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  data-testid={`input-${slotKey}-time`}
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  step="900" // <-- THIS IS YOUR FIX
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  />