import { useState, useMemo } from "react";
import { useQuery, useMutation, useQueryClient } from "@tanstack/react-query";
import { DndContext, DragOverlay, useDraggable, useDroppable, DragEndEvent, DragStartEvent } from "@dnd-kit/core";
import { CSS } from "@dnd-kit/utilities";
import { format } from "date-fns";
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select";
import { Badge } from "@/components/ui/badge";
import { ScrollArea, ScrollBar } from "@/components/ui/scroll-area";
import { Loader2, Calendar, GripVertical, ChevronUp, ChevronDown, Search, ZoomIn, ZoomOut, Filter } from "lucide-react";
import { apiRequest } from "@/lib/queryClient";
import { useToast } from "@/hooks/use-toast";
import { Input } from "@/components/ui/input";
import { Button } from "@/components/ui/button";
import { Slider } from "@/components/ui/slider";
import { cn } from "@/lib/utils";
import type { Game, Diamond, Team, TournamentDiamondAllocation } from "@shared/schema";

interface ScheduleBuilderProps {
  tournamentId: string;
  startDate: string;
  endDate: string;
  diamonds: Diamond[];
  teams: Team[];
}

// --- TEAM LOGO COMPONENT ---
// Renders an image if available, or a nice "Jersey" fallback
function TeamLogo({ team, size = "sm" }: { team?: Team, size?: "sm" | "md" }) {
  const sizeClasses = size === "sm" ? "w-5 h-5 text-[9px]" : "w-8 h-8 text-xs";
  
  if (!team) return <div className={cn("rounded-full bg-muted flex-shrink-0", sizeClasses)} />;

  // Fallback for no logo: Generate a color from the name string
  const stringToColor = (str: string) => {
    let hash = 0;
    for (let i = 0; i < str.length; i++) {
      hash = str.charCodeAt(i) + ((hash << 5) - hash);
    }
    const c = (hash & 0x00ffffff).toString(16).toUpperCase();
    return "#" + "00000".substring(0, 6 - c.length) + c;
  };

  // If schema adds logoUrl later, use it here:
  // if (team.logoUrl) return <img src={team.logoUrl} className={cn("rounded-full object-cover", sizeClasses)} />;

  const bgColor = stringToColor(team.name);
  const initials = team.name.substring(0, 2).toUpperCase();

  return (
    <div 
      className={cn("rounded-full flex items-center justify-center font-bold text-white shadow-sm flex-shrink-0", sizeClasses)}
      style={{ backgroundColor: bgColor }}
      title={team.name}
    >
      {initials}
    </div>
  );
}

// --- DRAGGABLE GAME CARD ---
function DraggableGame({ game, teams, isOverlay = false, isCompact = false }: { game: Game, teams: Team[], isOverlay?: boolean, isCompact?: boolean }) {
  const { attributes, listeners, setNodeRef, transform, isDragging } = useDraggable({
    id: game.id,
    data: { game },
    disabled: isOverlay
  });

  const style = transform ? {
    transform: CSS.Translate.toString(transform),
    opacity: isDragging ? 0.5 : 1,
    zIndex: 999,
  } : undefined;

  const homeTeam = teams.find(t => t.id === game.homeTeamId);
  const awayTeam = teams.find(t => t.id === game.awayTeamId);

  return (
    <div
      ref={setNodeRef}
      style={style}
      {...listeners}
      {...attributes}
      className={cn(
        "bg-card border rounded shadow-sm cursor-grab active:cursor-grabbing text-xs transition-all hover:border-primary group overflow-hidden",
        isCompact 
            ? "w-[240px] flex-shrink-0 h-full border-l-4 border-l-muted-foreground p-2 flex flex-col justify-center" 
            : "p-1.5 w-full h-full border-l-4 border-l-primary flex flex-col",
        isOverlay ? "scale-105 shadow-xl rotate-1 w-[240px]" : "",
        game.status === 'completed' ? "opacity-60 grayscale" : ""
      )}
    >
      {/* Matchup Row */}
      <div className="flex items-center justify-between gap-2 mb-1">
        <div className="flex items-center gap-1.5 min-w-0 flex-1">
             {/* Away Team */}
             <TeamLogo team={awayTeam} size="sm" />
             <span className="truncate font-semibold">{awayTeam?.name || "TBD"}</span>
        </div>
        
        <div className="text-[10px] text-muted-foreground font-bold px-1">vs</div>
        
        <div className="flex items-center gap-1.5 min-w-0 flex-1 justify-end">
             <span className="truncate font-semibold text-right">{homeTeam?.name || "TBD"}</span>
             {/* Home Team */}
             <TeamLogo team={homeTeam} size="sm" />
        </div>
      </div>

      {/* Metadata Row */}
      <div className="flex justify-between items-center text-[10px] text-muted-foreground mt-auto pt-1 border-t border-border/50">
        <div className="flex items-center gap-1">
            <GripVertical className="h-3 w-3 opacity-30 group-hover:opacity-100 transition-opacity" />
            <Badge variant="secondary" className="text-[9px] h-4 px-1 rounded-[2px] font-normal bg-muted/50">
                {game.poolId ? "Pool" : "Bracket"}
            </Badge>
        </div>
        <span className="font-mono bg-muted/30 px-1 rounded">
            {game.durationMinutes || 90}m
        </span>
      </div>
    </div>
  );
}

// --- DROP ZONE SLOT ---
function TimeSlot({ 
  diamondId, 
  time, 
  game, 
  teams, 
  allocation,
  isOver,
  height
}: { 
  diamondId: string, 
  time: string, 
  game?: Game, 
  teams: Team[],
  allocation?: TournamentDiamondAllocation,
  isOver: boolean,
  height: number
}) {
  const { setNodeRef } = useDroppable({
    id: `${diamondId}::${time}`,
    data: { diamondId, time }
  });

  // Visual State Logic
  let bgClass = "bg-background"; // Default empty
  
  if (!allocation) {
    // Locked: Striped pattern
    bgClass = "bg-muted/20 repeating-linear-gradient(45deg,transparent,transparent_5px,var(--muted)_5px,var(--muted)_10px)";
  } else {
    // Open: clean card background
    bgClass = "bg-card/30"; 
  }

  if (isOver) bgClass = "bg-primary/10 ring-2 ring-primary ring-inset"; // Active Drop Target

  return (
    <div
      ref={setNodeRef}
      style={{ height: `${height}px` }}
      className={cn(
        "border-b border-r relative p-1 transition-all",
        bgClass,
        game ? "p-0.5 overflow-hidden" : "" // Tight padding if game exists
      )}
    >
      {/* Empty Slot Time Label */}
      {!game && (
        <span className="absolute top-1 left-1 text-[9px] text-muted-foreground/20 select-none pointer-events-none font-mono">
          {time}
        </span>
      )}

      {/* Game Content */}
      {game && (
        <DraggableGame game={game} teams={teams} />
      )}
    </div>
  );
}

// --- MAIN COMPONENT ---
export function ScheduleBuilder({ tournamentId, startDate, endDate, diamonds, teams }: ScheduleBuilderProps) {
  const { toast } = useToast();
  const queryClient = useQueryClient();
  
  // State
  const [selectedDate, setSelectedDate] = useState(startDate);
  const [activeDragId, setActiveDragId] = useState<string | null>(null);
  const [draggedGame, setDraggedGame] = useState<Game | null>(null);
  const [isDeckExpanded, setIsDeckExpanded] = useState(true);
  const [bullpenSearch, setBullpenSearch] = useState("");
  const [zoomLevel, setZoomLevel] = useState(80); // Height in px

  // 1. Data Fetching
  const { data: games = [] } = useQuery<Game[]>({
    queryKey: [`/api/tournaments/${tournamentId}/games`],
  });
  const { data: allocations = [] } = useQuery<TournamentDiamondAllocation[]>({
    queryKey: [`/api/tournaments/${tournamentId}/allocations`],
  });

  // 2. Mutation
  const moveGameMutation = useMutation({
    mutationFn: async (data: { gameId: string, date: string, time: string, diamondId: string }) => {
      return apiRequest("PUT", `/api/games/${data.gameId}/move`, {
        date: data.date,
        time: data.time,
        diamondId: data.diamondId
      });
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: [`/api/tournaments/${tournamentId}/games`] });
      toast({ title: "Success", description: "Game rescheduled." });
    },
    onError: (err: any) => {
      toast({ title: "Conflict", description: err.message, variant: "destructive" });
    }
  });

  // 3. Filters & Memos
  const unscheduledGames = useMemo(() => 
    games.filter(g => !g.diamondId || !g.time || !g.date)
         .filter(g => {
            // Search Filter
            if (!bullpenSearch) return true;
            const home = teams.find(t => t.id === g.homeTeamId)?.name.toLowerCase() || "";
            const away = teams.find(t => t.id === g.awayTeamId)?.name.toLowerCase() || "";
            const q = bullpenSearch.toLowerCase();
            return home.includes(q) || away.includes(q);
         }), 
  [games, bullpenSearch, teams]);

  const scheduledGames = useMemo(() => 
    games.filter(g => g.diamondId && g.time && g.date === selectedDate), 
  [games, selectedDate]);

  const dayAllocations = useMemo(() => 
    allocations.filter(a => a.date === selectedDate),
  [allocations, selectedDate]);

  const dateOptions = useMemo(() => {
    const dates = [];
    let curr = new Date(startDate + "T00:00:00");
    const end = new Date(endDate + "T00:00:00");
    while (curr <= end) {
      dates.push(format(curr, "yyyy-MM-dd"));
      curr.setDate(curr.getDate() + 1);
    }
    return dates;
  }, [startDate, endDate]);

  const timeSlots = useMemo(() => {
    const times = [];
    for (let h = 8; h < 23; h++) {
      times.push(`${h.toString().padStart(2, '0')}:00`);
      times.push(`${h.toString().padStart(2, '0')}:30`);
    }
    return times;
  }, []);

  // 4. Handlers
  const handleDragStart = (event: DragStartEvent) => {
    setActiveDragId(event.active.id as string);
    setDraggedGame(event.active.data.current?.game);
  };

  const handleDragEnd = (event: DragEndEvent) => {
    const { active, over } = event;
    if (over && active.id !== over.id) {
      const [diamondId, time] = (over.id as string).split("::");
      if (diamondId && time) {
        moveGameMutation.mutate({
          gameId: active.id as string,
          date: selectedDate,
          time,
          diamondId
        });
      }
    }
    setActiveDragId(null);
    setDraggedGame(null);
  };

  return (
    <DndContext onDragStart={handleDragStart} onDragEnd={handleDragEnd}>
      <div className="flex flex-col h-[calc(100vh-140px)] bg-background">
        
        {/* --- TOP BAR: CONTROLS --- */}
        <div className="flex justify-between items-center p-3 border-b bg-card shadow-sm z-10 gap-4">
            <div className="flex items-center gap-4">
                <Select value={selectedDate} onValueChange={setSelectedDate}>
                    <SelectTrigger className="w-[220px] bg-background border-muted-foreground/20">
                        <SelectValue />
                    </SelectTrigger>
                    <SelectContent>
                        {dateOptions.map(d => (
                            <SelectItem key={d} value={d}>{format(new Date(d + "T00:00:00"), "EEEE, MMM d")}</SelectItem>
                        ))}
                    </SelectContent>
                </Select>

                {/* Zoom Control */}
                <div className="hidden md:flex items-center gap-2 border-l pl-4">
                    <ZoomOut className="h-4 w-4 text-muted-foreground" />
                    <Slider 
                        value={[zoomLevel]} 
                        onValueChange={(v) => setZoomLevel(v[0])} 
                        min={50} 
                        max={150} 
                        step={10} 
                        className="w-[100px]" 
                    />
                    <ZoomIn className="h-4 w-4 text-muted-foreground" />
                </div>
            </div>
            
            <div className="flex gap-4 text-xs text-muted-foreground items-center">
                <div className="flex items-center gap-1.5"><span className="w-2 h-2 bg-card/30 border rounded-full"/> Open</div>
                <div className="flex items-center gap-1.5"><span className="w-2 h-2 bg-muted/20 border rounded-full"/> Locked</div>
                <div className="flex items-center gap-1.5"><span className="w-2 h-2 bg-primary rounded-full"/> Game</div>
            </div>
        </div>

        {/* --- MAIN: SCHEDULING GRID --- */}
        <div className="flex-1 overflow-hidden relative flex bg-muted/5">
            {/* Y-Axis: Time Labels */}
            <div className="w-14 flex-shrink-0 border-r bg-card z-20 overflow-hidden shadow-lg">
                <div className="h-10 border-b bg-muted/50" /> {/* Corner Spacer */}
                <ScrollArea className="h-full">
                    {timeSlots.map(t => (
                        <div key={t} style={{ height: `${zoomLevel}px` }} className="border-b text-[10px] text-muted-foreground flex items-center justify-center font-mono bg-card select-none">
                            {t}
                        </div>
                    ))}
                    <div className="h-32" /> {/* Bottom Padding for scroll */}
                </ScrollArea>
            </div>

            {/* The Grid */}
            <ScrollArea className="flex-1" type="always">
                <div className="flex min-w-max">
                   {diamonds.map(diamond => (
                       <div key={diamond.id} className="flex flex-col w-[220px] border-r border-border/50">
                           {/* Sticky Header */}
                           <div className="h-10 sticky top-0 z-10 bg-card border-b flex items-center justify-center px-2 shadow-sm group">
                               <span className="text-xs font-bold truncate text-card-foreground group-hover:text-primary transition-colors">
                                 {diamond.name}
                               </span>
                           </div>
                           
                           {/* Slots */}
                           {timeSlots.map(time => {
                               const alloc = dayAllocations.find(a => a.diamondId === diamond.id && a.startTime <= time && a.endTime > time);
                               const game = scheduledGames.find(g => g.diamondId === diamond.id && g.time === time);
                               
                               return (
                                   <TimeSlot 
                                       key={`${diamond.id}-${time}`}
                                       diamondId={diamond.id}
                                       time={time}
                                       game={game}
                                       teams={teams}
                                       allocation={alloc}
                                       isOver={false}
                                       height={zoomLevel}
                                   />
                               );
                           })}
                           <div className="h-32 bg-muted/10" /> {/* Bottom Padding */}
                       </div>
                   ))}
                </div>
                <ScrollBar orientation="horizontal" />
            </ScrollArea>
        </div>

        {/* --- BOTTOM DECK: BULLPEN --- */}
        <div className={cn(
            "border-t bg-card transition-all duration-300 flex flex-col shadow-[0_-4px_20px_-5px_rgba(0,0,0,0.1)] z-30 relative",
            isDeckExpanded ? "h-60" : "h-12"
        )}>
            {/* Toggle Tab (Center) */}
            <div 
                className="absolute -top-5 left-1/2 -translate-x-1/2 bg-card border border-b-0 rounded-t-xl px-6 py-1 cursor-pointer shadow-sm hover:text-primary"
                onClick={() => setIsDeckExpanded(!isDeckExpanded)}
            >
                {isDeckExpanded ? <ChevronDown className="h-4 w-4" /> : <ChevronUp className="h-4 w-4" />}
            </div>

            {/* Header Bar */}
            <div className="h-12 border-b flex items-center justify-between px-4 bg-muted/10">
                <div className="flex items-center gap-2 text-sm font-bold">
                    <Calendar className="h-4 w-4 text-primary" />
                    Bullpen
                    <Badge variant="secondary" className="ml-2 bg-primary/10 text-primary border-primary/20">{unscheduledGames.length}</Badge>
                </div>
                
                {/* Bullpen Filter */}
                <div className="relative w-64">
                    <Search className="absolute left-2 top-1/2 -translate-y-1/2 h-3 w-3 text-muted-foreground" />
                    <Input 
                        className="h-8 pl-8 text-xs bg-background" 
                        placeholder="Filter games..." 
                        value={bullpenSearch}
                        onChange={(e) => setBullpenSearch(e.target.value)}
                    />
                </div>
            </div>

            {/* Deck Content */}
            {isDeckExpanded && (
                <ScrollArea className="flex-1 p-4 bg-muted/5">
                    <div className="flex gap-3 pb-2 min-w-max">
                        {unscheduledGames.length === 0 ? (
                             <div className="w-full flex flex-col items-center justify-center text-sm text-muted-foreground italic border-2 border-dashed border-muted rounded-lg h-32 w-[600px] mx-auto">
                                 <div className="bg-primary/10 p-3 rounded-full mb-2">
                                     <Calendar className="h-6 w-6 text-primary" />
                                 </div>
                                 All games placed for {format(new Date(selectedDate), "MMM d")}!
                             </div>
                        ) : (
                            unscheduledGames.map(game => (
                                <div key={game.id} className="h-32">
                                    <DraggableGame game={game} teams={teams} isCompact={true} />
                                </div>
                            ))
                        )}
                    </div>
                    <ScrollBar orientation="horizontal" />
                </ScrollArea>
            )}
        </div>

      </div>

      {/* DRAG OVERLAY */}
      <DragOverlay>
        {activeDragId && draggedGame ? (
           <DraggableGame game={draggedGame} teams={teams} isOverlay={true} isCompact={true} />
        ) : null}
      </DragOverlay>
    </DndContext>
  );
}